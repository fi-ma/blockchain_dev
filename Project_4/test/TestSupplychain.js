// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
const SupplyChain = artifacts.require('SupplyChain');
const fs = require('fs');

contract('SupplyChain', (accounts) => {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    let supplyChain;
    let sku = 1;
    let upc = 1;
    const ownerID = accounts[0];
    const originFarmerID = accounts[1];
    const originFarmName = "Several Small Farmers";
    const originFarmInformation = "Terroir Caldas";
    const originFarmElevation = 1800;
    const originFarmLatitude = "-38.239770";
    const originFarmLongitude = "144.341490";
    const originProductCultivar = "Colombia & Castillo Naranjal";
    const productNotes = "Brown Sugar / Guava / Honey / Cocoa";
    const productScore = "89.75";
    const productSizeLot = 1200;
    const productFOBPrice = web3.utils.toWei("1", "ether");
    const productPrice = web3.utils.toWei("2", "ether");
    const productPriceToPay = web3.utils.toWei("2.5", "ether");
    const processorID = accounts[2];
    const distributorID = accounts[3];
    const roasterID = accounts[4];
    const retailerID = accounts[5];
    const consumerID = accounts[6];

    console.log("ganache-cli accounts used here...");
    console.log(`Contract Owner: ${ownerID}`);
    console.log(`Farmer: ${originFarmerID}`);
    console.log(`Processor: ${processorID}`);
    console.log(`Distributor: ${distributorID}`);
    console.log(`Roaster: ${roasterID}`);
    console.log(`Retailer: ${retailerID}`);
    console.log(`Consumer: ${consumerID}`);

    before(async() => {
        supplyChain = await SupplyChain.deployed();

        // Add identities to Roles
        await supplyChain.addFarmer(originFarmerID, { from: ownerID });
        await supplyChain.addProcessor(processorID, { from: ownerID });
        await supplyChain.addDistributor(distributorID, { from: ownerID });
        await supplyChain.addRoaster(roasterID, { from: ownerID });
        await supplyChain.addRetailer(retailerID, { from: ownerID });
        await supplyChain.addConsumer(consumerID, { from: ownerID });

        // Mark an item as Grown by calling function growItem()
        await supplyChain.growItem(
            upc,
            originFarmName,
            originFarmInformation,
            originFarmElevation,
            originFarmLatitude,
            originFarmLongitude,
            originProductCultivar,
            { from: originFarmerID }
        );
    })

    // 1st Test
    it("Testing smart contract function growItem() that allows a farmer to grow coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Check for 'Grown' events
        const events = await supplyChain.getPastEvents("Grown", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU');
        assert.equal(resultBufferOne[1], originFarmerID, 'Error: Missing or Invalid ownerID');
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Missing or Invalid originFarmerID');
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Missing or Invalid originFarmName');
        assert.equal(resultBufferOne[4], originFarmInformation, 'Error: Missing or Invalid originFarmInformation');
        assert.equal(resultBufferOne[5], originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude');
        assert.equal(resultBufferOne[6], originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude');
        assert.equal(resultBufferTwo[1], originFarmElevation, 'Error: Missing or Invalid originFarmElevation');
        assert.equal(resultBufferTwo[3], originProductCultivar, 'Error: Missing or Invalid originProductCultivar');
        assert.equal(resultBufferFour[3], 0, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 2nd Test
    it("Testing smart contract function pickItem() that allows a farmer to pick coffee cherries", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Picked by calling function pickItem()
        await supplyChain.pickItem(upc, { from: originFarmerID });

        // Check for 'Picked' events
        const events = await supplyChain.getPastEvents("Picked", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.isAbove(parseInt(resultBufferTwo[2]), 0, 'Error: Invalid originFarmPickedAt');
        assert.equal(resultBufferFour[3], 1, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 3rd Test
    it("Testing smart contract function processItem() that allows a processor to process coffee cherries", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Processed by calling function processItem()
        await supplyChain.processItem(upc, 1, { from: processorID });

        // Check for 'Processed' events
        const events = await supplyChain.getPastEvents("Processed", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], processorID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFour[4], processorID, 'Error: Invalid processorID');
        assert.equal(resultBufferTwo[5], 1, 'Error: Invalid productProcessType');
        assert.equal(resultBufferFour[3], 2, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })    

    // 4th Test
    it("Testing smart contract function tasteItem() that allows a distributor to taste coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Tasted by calling function tasteItem()
        await supplyChain.tasteItem(upc, productNotes, { from: distributorID });

        // Check for 'Tasted' events
        const events = await supplyChain.getPastEvents("Tasted", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], distributorID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFour[5], distributorID, 'Error: Invalid distributorID');
        assert.equal(resultBufferTwo[6], productNotes, 'Error: Invalid productProcessType');
        assert.equal(resultBufferFour[3], 3, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 5th Test
    it("Testing smart contract function gradeItem() that allows a distributor to score coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Graded by calling function gradeItem()
        await supplyChain.gradeItem(upc, productScore, { from: distributorID });

        // Check for 'Graded' events
        const events = await supplyChain.getPastEvents("Graded", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferTwo[6], productNotes, 'Error: Invalid productProcessType');
        assert.equal(resultBufferThree[1], true, 'Error: Invalid productIsScored');
        assert.equal(resultBufferThree[2], productScore, 'Error: Invalid productScore');
        assert.equal(resultBufferFour[3], 4, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 6th Test
    it("Testing smart contract function sellItem() that allows a processor to sell coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Sold by calling function sellItem()
        await supplyChain.sellItem(upc, productSizeLot, { from: processorID });

        // Check for 'Sold' events
        const events = await supplyChain.getPastEvents("Sold", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], processorID, 'Error: Invalid ownerID');
        assert.equal(resultBufferThree[3], productSizeLot, 'Error: Invalid productSizeLot');
        assert.equal(resultBufferFour[3], 5, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 7th Test
    it("Testing smart contract function packItem() that allows a processor to pack coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Packed by calling function packItem()
        await supplyChain.packItem(upc, { from: processorID });

        // Check for 'Packed' events
        const events = await supplyChain.getPastEvents("Packed", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferFour[3], 6, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 8th Test
    it("Testing smart contract function listItem() that allows a distributor to list coffee for sale", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Listed by calling function listItem()
        await supplyChain.listItem(upc, { from: distributorID });

        // Check for 'Listed' events
        const events = await supplyChain.getPastEvents("Listed", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], distributorID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFour[3], 7, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 9th Test
    it("Testing smart contract function buyItem() that allows a roaster to buy green coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Bought by calling function buyItem()
        await supplyChain.buyItem(upc, productFOBPrice, { from: roasterID });

        // Check for 'Bought' events
        const events = await supplyChain.getPastEvents("Bought", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], roasterID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFour[6], roasterID, 'Error: Invalid roasterID');
        assert.equal(resultBufferThree[4], productFOBPrice, 'Error: Invalid productProcessType');
        assert.equal(resultBufferFour[3], 8, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 10th Test
    it("Testing smart contract function shipItem() that allows a distributor to ship coffee to roaster", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Shipped by calling function shipItem()
        await supplyChain.shipItem(upc, { from: distributorID });

        // Check for 'Shipped' events
        const events = await supplyChain.getPastEvents("Shipped", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], distributorID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFour[3], 9, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 11th Test
    it("Testing smart contract function receiveItem() that allows a roaster to receive green coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Received by calling function receiveItem()
        await supplyChain.receiveItem(upc, { from: roasterID });

        // Check for 'Received' events
        const events = await supplyChain.getPastEvents("Received", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], roasterID, 'Error: Invalid ownerID');
        assert.isAbove(parseInt(resultBufferThree[5]), 0, 'Error: Invalid productReceivedAt');
        assert.equal(resultBufferFour[3], 10, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 12th Test
    it("Testing smart contract function roastItem() that allows a roaster to roast green coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Roasted by calling function roastItem()
        await supplyChain.roastItem(upc, 1, { from: roasterID });

        // Check for 'Roasted' events
        const events = await supplyChain.getPastEvents("Roasted", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);
        
        // Verify the result set
        assert.equal(resultBufferThree[6], 1, 'Error: Invalid productRoastedFor');
        assert.isAbove(parseInt(resultBufferFour[1]), 0, 'Error: Invalid productRoastedAt');
        assert.equal(resultBufferFour[3], 11, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 13th Test
    it("Testing smart contract function offerItem() that allows a retailer to offer roasted coffee for purchase", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;
        
        // Mark an item as Offered by calling function offerItem()
        await supplyChain.offerItem(upc, productPrice, { from: retailerID });

        // Check for 'Offered' events
        const events = await supplyChain.getPastEvents("Offered", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);
        const resultBufferFive = await supplyChain.fetchItemBufferFive.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], retailerID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFive[1], retailerID, 'Error: Invalid retailerID');
        assert.equal(resultBufferFour[2], productPrice, 'Error: Invalid productPrice');
        assert.equal(resultBufferFour[3], 12, 'Error: Invalid item State');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 14th Test
    it("Testing smart contract function purchaseItem() that allows a consumer to purchase roasted coffee", async() => {
        // Declare and Initialize a variable for event
        let eventEmitted = false;

        // Check the account balances before transfer
        const consumerBalanceBefore = await web3.eth.getBalance(consumerID);
        const retailerBalanceBefore = await web3.eth.getBalance(retailerID);
        
        // Mark an item as Purchased by calling function purchaseItem()
        await supplyChain.purchaseItem(upc, {
            from: consumerID,
            value: productPriceToPay,
            gasPrice: 0
        });

        // Check the account balances after transfer
        const consumerBalanceAfter = await web3.eth.getBalance(consumerID);
        const retailerBalanceAfter = await web3.eth.getBalance(retailerID);

        const consumerBalanceDiff = Number(consumerBalanceBefore) - Number(consumerBalanceAfter);
        const retailerBalanceDiff = Number(retailerBalanceAfter) - Number(retailerBalanceBefore);

        // Check for 'Purchased' events
        const events = await supplyChain.getPastEvents("Purchased", {});

        if (events.length === 1) eventEmitted = true;

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);
        const resultBufferFive = await supplyChain.fetchItemBufferFive.call(upc);

        // Verify the result set
        assert.equal(resultBufferOne[1], consumerID, 'Error: Invalid ownerID');
        assert.equal(resultBufferFive[2], consumerID, 'Error: Invalid consumerID');
        assert.equal(resultBufferFour[3], 13, 'Error: Invalid item State');
        assert.equal(consumerBalanceDiff, productPrice, 'Error: Invalid consumer balance');
        assert.equal(retailerBalanceDiff, productPrice, 'Error: Invalid retailer balance');
        assert.equal(eventEmitted, true, 'Invalid event emitted');
    })

    // 15th Test
    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
        
        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid SKU');
        assert.equal(resultBufferOne[1], consumerID, 'Error: Invalid consumerID');
        assert.equal(resultBufferOne[2], originFarmerID, 'Error: Invalid originFarmerID');
        assert.equal(resultBufferOne[3], originFarmName, 'Error: Invalid originFarmName');
        assert.equal(resultBufferOne[4], originFarmInformation, 'Error: Invalid originFarmInformation');
        assert.equal(resultBufferOne[5], originFarmLatitude, 'Error: Invalid originFarmLatitude');
        assert.equal(resultBufferOne[6], originFarmLongitude, 'Error: Invalid originFarmLongitude');
    })

    // 16th Test
    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

        // Verify the result set
        assert.equal(resultBufferTwo[0], sku, 'Error: Invalid SKU');
        assert.equal(resultBufferTwo[1], originFarmElevation, 'Error: Invalid originFarmElevation');
        assert.isAbove(parseInt(resultBufferTwo[2]), 0, 'Error: Invalid originFarmPickedAt');
        assert.equal(resultBufferTwo[3], originProductCultivar, 'Error: Invalid originProductCultivar');
        assert.isAbove(parseInt(resultBufferTwo[4]), 2**16, 'Error: Invalid productID');
        assert.equal(resultBufferTwo[5], 1, 'Error: Invalid productProcessType');
        assert.equal(resultBufferTwo[6], productNotes, 'Error: Invalid productNotes');
    })

    // 17th Test
    it("Testing smart contract function fetchItemBufferThree() that allows anyone to fetch item details from blockchain", async() => {
        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferThree = await supplyChain.fetchItemBufferThree.call(upc);
        
        // Verify the result set
        assert.equal(resultBufferThree[0], sku, 'Error: Invalid SKU');
        assert.equal(resultBufferThree[1], true, 'Error: Invalid productIsScored');
        assert.equal(resultBufferThree[2], "89.75", 'Error: Invalid productScore');
        assert.equal(resultBufferThree[3], 1200, 'Error: Invalid productLotSize');
        assert.equal(resultBufferThree[4], web3.utils.toWei("1", "ether"), 'Error: Invalid productFOBPrice');
        assert.isAbove(parseInt(resultBufferThree[5]), 0, 'Error: Invalid productReceivedAt');
        assert.equal(resultBufferThree[6], 1, 'Error: Invalid productRoastedFor');
    })

    // 18th Test
    it("Testing smart contract function fetchItemBufferFour() that allows anyone to fetch item details from blockchain", async() => {
        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferFour = await supplyChain.fetchItemBufferFour.call(upc);
        
        // Verify the result set
        assert.equal(resultBufferFour[0], sku, 'Error: Invalid SKU');
        assert.isAbove(parseInt(resultBufferFour[1]), 0, 'Error: Invalid productRoastedAt');
        assert.equal(resultBufferFour[2], web3.utils.toWei("2", "ether"), 'Error: Invalid productPrice');
        assert.equal(resultBufferFour[3], 13, 'Error: Invalid itemState');
        assert.equal(resultBufferFour[4], processorID, 'Error: Invalid processorID');
        assert.equal(resultBufferFour[5], distributorID, 'Error: Invalid distributorID');
        assert.equal(resultBufferFour[6], roasterID, 'Error: Invalid roasterID');
    })

    // 19th Test
    it("Testing smart contract function fetchItemBufferFive() that allows anyone to fetch item details from blockchain", async() => {
        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferFive = await supplyChain.fetchItemBufferFive.call(upc);
        
        // Verify the result set
        assert.equal(resultBufferFive[0], sku, 'Error: Invalid SKU');
        assert.equal(resultBufferFive[1], retailerID, 'Error: Invalid retailerID');
        assert.equal(resultBufferFive[2], consumerID, 'Error: Invalid consumerID');
    })
})